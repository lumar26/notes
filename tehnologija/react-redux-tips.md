# Shwartzmuller kurs

Redux je u stvari jedan __Observer__ patern gde se komponente pretplaćuju na centralno skladište.
Tok podataka je  samo u smeru od skladišta ka komponenti, nikad obrnuto, tj. komponenta ne menja stanje u skladištu.
Za promenu stanja u skladištu zadužene su __Reducer__ funkcije
Pošto komponenta treba na neki način da inicira promenu stanja aplikacije (jer uglavnom ono što se desi u komponenti jeste uslov za promenu stanja) moramo nekako da povežemo komponentu i Reducer funkciju. To se postiže uz pomoć _akcija_. Komponenta odašilja akciju nakon što se u komponenti nešto desilo. Ta akcija je js objekat koji sadrži informacije o događaju (identifikator, podatke potrebne za izmenu stanja) i koji Reducer funkcija prima kao parametar. Na osnovu tih parametara Reducer funkcija vrši promenu stanja

Reducer funkcija treba da bude _pure function_ u smislu da nema sporedne efekte (za isti ulaz uvek daje isti izlaz, nema uticaj na stanje van te funkcije). Ona vraca novo stanje (celo stanje, nikako deo stanja) koje Redux koristi da pregazi prethodno stanje

Pri kreiranju skladišta neophodno je definisati koje su to Reducer funkcije koje upravljaju stanjem.

`reduce` funkciju izvršava sam Redux -  programer je ne poziva nigde.  

___________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

## Postupak uvođenja Redux-a

1. Najpre treba da se definiše centralno skladište, to je ništa drugo do fajl u kojem se definise Redux Store. Kad se koristi redux-toolkit i funkcija `configureStore({reducer: {}})` imamo mogucnost da dodamo delove stanja koje smo definisali sa `createSlice()`. `reducer` moze da bude samo jedan reducer ili moze da bude mapa reducera koje posle Redux spaja u jedan veliki.

2. Za svaki deo globalnog stanja kreiramo __slice__ uz pomoc funkcije `createSlice({name, initialState, reducers: {//map of reducers}})`. Svaka od Reducer funkcija prima predjasnje stanje i akciju kao parametre, s tim sto te parametre po potrebi mozemo izostaviti (uglavnom izostavimo akciju ako nam ne treba *payload*)

3. Za svaki slice eksportujemo `slice.actions` odnosno kreatore akcija i njih mozemo da uvezemo u komponentu koja treba da odasilja te akcije. Odasiljanje tih akcija se radi na sl nacin: `dispatch(importedActions.action1())`. Bitno je da se funkcija izvrsi jer je njena povratna vrednost ustv ta akcija. Ukoliko ta akcija treba da ima payload onda se taj objekat prosledjuje toj action creator funkciji kao argument.

3. Da bi se komponenta pretplatila na stanje u centralnom skladistu (ili cesce na deo skladista) koristi se `useSelector()` udica kojoj se kao argument prosle]uje takodje funkcija `state => state.partOfState` 

4. Da bi se otposlala neka akcija iz komponente koja je generator dogadjaja koji menja stanje koristimo `useDispatch()`. Ova udica ne prima argumenta i vraca funkciju `dispatch`pomocu koje odasilja akciju.  `dispatch({type: "...", payload = {...}})`


## Redux toolkit

Kad koristimo `createSlice` redux-toolkit automatski generise akcije za taj slice: `someSlice.actions` nam daje funkcije od kojih svaka vraca _action_ objekat za datu funkciju sa izgenerisanim id-jem. To su tzv. __action creators__


___________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

# createSlice 

By default, the action creators generated by `createSlice` expect you to pass in one argument, and that value will be put into the action object as `action.payload`.

Redux Toolkit's `createSlice` API generates action creators and action types for each individual reducer function you provide

# When to use Redux:

Do other parts of the application care about this data?
Do you need to be able to create further derived data based on this original data?
Is the same data being used to drive multiple components?
Is there value to you in being able to restore this state to a given point in time (ie, time travel debugging)?
Do you want to cache the data (ie, use what's in state if it's already there instead of re-requesting it)?
Do you want to keep this data consistent while hot-reloading UI components (which may lose their internal state when swapped)?

# UI forms and  redux:

Most form state probably shouldn't be kept in Redux. Instead, keep the data in your form components as you're editing it, and then dispatch Redux actions to update the store when the user is done.

# Classic workflow:

adding slices of state,
writing reducer functions,
dispatching actions,
and rendering the UI based on data from the Redux store.

# Rerendering by using useSelector

It's important to note that the component will re-render any time the value returned from useSelector changes to a new reference. Components should always try to select the smallest possible amount of data they need from the store, which will help ensure that it only renders when it actually needs to.

# Caveat

If an action needs to contain a unique ID or some other random value, always generate that first and put it in the action object. Reducers should never calculate random values, because that makes the results unpredictable.

# Prepare function inside single reducer

Služi za predefinisanje **action.payload**

reducers: {
    postAdded: {
      reducer(state, action) {
        state.push(action.payload)
      },
      prepare(title, content, userId) {
        return {
          payload: {
            id: nanoid(),
            title,
            content,
            user: userId
          }
        }
      }
    }
    // other reducers
  }



# Usual aproach

Notice that we're following the same pattern in each of our components as we go. Any component that needs to read data from the Redux store can use the useSelector hook, and extract the specific pieces of data that it needs. Also, many components can access the same data in the Redux store at the same time.
