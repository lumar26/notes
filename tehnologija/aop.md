# *Aspect Oriented Programming* (**AOP**)

Аспектно оријентисано програмирање је парадигма програмирања чији је циљ да превазиђе проблеме у имплементацији који се јављају као последица постојања функционалности које се преплићу и/или стално понављају у другим деловима кода а не представљају основну функционалност. Најчешћи пример једне овакве функционалности јесу: 

- логовање порука
- управљање трансакцијама
- управљање улазно/излазним токовима
- безбедност

## Други начини решавања проблема  додатних функционалности

Када се развија озбиљан софтвер наравно постоје неке акције, случајеви коришћења и операције који су по природни комплексни. Узећемо за пример скидање новца са неког рачуна.

У комплексним апликацијама горе наведени примери функционалности који прате пословну логику су неопходни али могу да учине код веома комплексним. У таквим случајевима, пратећи добре праксе, треба испоштовати један од SOLID принципа развоја софтвера а то је *Separation of concerns* или "подела одговорности". То значи да систем треба креирати тако да буде модуларан, тј. да сваки модул, логичка целина, буде задужена са што мањи обим посла, у најбољем случају за једну јединицу посла. 

Поштујући овај принцип у објектно оријентисаном програмирању у одвојене класе издвојићемо код за управљање конекцијом са базом, за управљање трансакцијама, за логовање порука итд. У питању је класична **композиција**.

```java
public void withdraw(double amount, long accountId){
    repository.openConnection();
    logger.info("Connection with db established");
    try {
        Account account = repo.getAccountById(accountId); // бизнис логика
        if(account.balance < amount) throw new Exception("Not enough money"); // бизнис логика, занемарити лошу праксу
        account.setBalance(account.balance - amount);// бизнис логика
        repo.save(account);// бизнис логика
        repository.commit();
        logger.info("Updated balance");
    } catch (SQLException sqle){
        logger.error(sgle.getMessage());
        repository.rollback();
    } catch (Exception e){
        logger.error();
		repository.rollback();
    }
    repository.closeConnection();
    logger.info("Connection closed");
}
```

На претходном, упрошћеном и не потпуно реалном примеру, може се уочити потенцијална ситуација у коду када је потребно поред основне функционалности укључити и доста пратећих. У идеалном случају по оног ко пише код и оног ко чита ова метода треба да има 4 линије које се баве само пословном логиком док остале пратеће функционалности треба издвојити у неким другим класама.

## Опис

Ова парадигма се остварује такође повећаном модуларношћу софтвера тако што се те потребне функционалности издвајају у засебне ентитете који се називају **аспекти**. Аспекти су, наравно, наравно, такође класе али су специјализоване управо за овакву потребу поделе одговорности.

Аспект функционише на тај начин што се у оквиру дефиниције аспекта одређује која ће се акција/процедура узвршити. Дакле, у аспекту се само дефинише "шта" али не и "када" или "где". "Када" и "где"  су дефинисани у оквиру издвојене конфигурације у којој дефинишемо над којом **методом** се извршава нека процедура из аспекта и у ком тренутку (пре и/или после позива методе). Постојање конфигурације аспеката у оквиру издвојеног конфигурационог фајла нам даје централизовану локацију управљања и подешавања аспеката. То значи да није потребно мењати код пословне логике како би се нека функционалност додала или одузела.

Битно је нагласити да се AOP фокусира на понашање система - његове функционалности. Како је понашање у OOP  садржано у методама класа тако ће аспекти и њихова конфигурација бити фокусирани на методе, тј. појединим методама ће бити додата понашања која је окружују (код који се извшава пре или после).

### AOP vs Decorator

Још једна битна чињеница и недоумица је повезаност између AOP и *Decorator Pettern*-a дизајнирања у OOP. Истина је да деле сличне или идентичне замисли као што је додавање функционалности већ постојећим али се не могу поистоветити. AOP се имплементира на нивоу фрејмворка или програмског језика и за његову имплементацију се могу користити најчешће *Decorator Pettern* и *Proxy* у неком облику. Са друге стране *Decorator Pettern* је семантичка творевина и егзибиција у оквиру OOP парадигме. 

Такође функционалности уведене уз помоћ AOP се примењују на целу класу објеката док се *Decorator Pettern* користи за појединачне инстанце

### Процес

У овом примеру било би потребно да се направе посебни аспекти за логовање, за управљање конекцијом и управљање трансакцијом. Процес имплементације AOP-a се састоји из само два корака:

- писање аспеката;
- писање конфигурације.


